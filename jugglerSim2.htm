<html>
<head>

<style>

	.graph {
		width: 95%;
		height: 20%;
		top: 80%;
		position:absolute;
	}
	
	#info {
		position:absolute;
		left: 250px;
	}

</style>
		

	<script type="text/javascript" src="jquery.js"></script>
	<script language="javascript" type="text/javascript" src="flot/jquery.flot.js"></script>
	<script type="text/javascript" src="dat.gui.min.js"></script>
	<script src="Three.js"></script>
	
	<script src="solenoid.js"></script>

<script type="text/javascript">
$(function() {

  var mx = 0;
  var my = 0;
  var md = false;

  var JugglerControl = function() {
	  this.P = 50;
	  this.I = 0.0;
	  this.D = 0;
	  this.IDecay = 1.0;
	  this.gravity = 0.98;
	  this.targetDist = 70;
	  this.sensorNoise = 0;
	  this.pause = false;
	  this.maxRot = 0;
	  
	  this.phase = false;
	  this.coast = false;
	  this.targetAng = 1;
	  this.oscillations = 0;
	  this.driveV = 0;
	};
	
	var jugControl = new JugglerControl();


  var ThePID = function() {
  	 this.error = 0.0;
  	 this.lerror = 0.0;
  	 this.derror = 0.0;
  	 this.ierror = 0.0;
  	 this.smootherror = 0.0;
  	 
  };
  
  var PID = new ThePID();

	window.onload = function() {
	  
	  var gui = new dat.GUI();
	  gui.add(jugControl, 'P', 0, 1000);
	  gui.add(jugControl, 'I', 0, 10, 0.1);
	  gui.add(jugControl, 'D', -100, 100);
	  gui.add(jugControl, 'IDecay', 0.0, 1.0);
	  gui.add(jugControl, 'gravity', 0, 20);
	  gui.add(jugControl, 'targetDist', 0, 200);
	  gui.add(jugControl, 'sensorNoise',0,10);
	  gui.add(jugControl, 'pause');
	  gui.add(jugControl, 'maxRot',0,6);
	  
	  //gui.remember(jugControl);
	};


  // set the scene size
	var WIDTH = window.innerWidth,
	    HEIGHT = window.innerHeight;

	// set some camera attributes
	var VIEW_ANGLE = 45,
	    ASPECT = WIDTH / HEIGHT,
	    NEAR = 0.1,
	    FAR = 10000;
	    
	var frame = 0;
	var simTime = 0;
	var lastTime = new Date();
	    
	    
	var camera, scene, renderer;
	var sphere;
	var magnet;
	var targetLine;
	var sphereLine;
	
	var data = [];
	var totalPoints = 1000;
	
	for (var i=1; i<totalPoints; i++) {
		data.push([i,0]);
	}
	
	
	function getData() {
		return data;
	}
	
	var plot;

	function updatePlot() {
		plot.setData([getData()]);
		plot.setupGrid();
		plot.draw();
	}

			

	function init() {

		renderer = new THREE.WebGLRenderer();
		renderer.setSize( window.innerWidth, window.innerHeight );
		document.body.appendChild( renderer.domElement );

		//

		camera = new THREE.PerspectiveCamera(  VIEW_ANGLE,
	                                ASPECT,
	                                NEAR,
	                                FAR  );
		camera.position.z = 300;

		scene = new THREE.Scene();


		// SPHERE ************
		// create the sphere's material
		var sphereMaterial = new THREE.MeshLambertMaterial(
		{
			color: 0xF0F0F0
		});

		// set up the sphere vars
		var radius = 20, segments = 16, rings = 16;

		// create a new mesh with sphere geometry -
		// we will cover the sphereMaterial next!
		sphere = new THREE.Mesh(
		   new THREE.SphereGeometry(radius, segments, rings),
		   sphereMaterial);

		sphere.position.y  = 30;
		// add the sphere to the scene
		scene.add(sphere);
		
		sphere.v = new THREE.Vector2(0,0);
		
		
		// MAGNET ***************
		
		var magnetMaterial = new THREE.MeshLambertMaterial(
		{
			color: 0x808080
		});
		
		magnet = new THREE.Mesh(
			new THREE.CubeGeometry( 20, 50, 20 ),
			magnetMaterial);
			
		magnet.position.y = 100;
		scene.add(magnet);
		
		
		// TARGET DIST LINE **************
		
		var geometry = new THREE.Geometry();
    	geometry.vertices.push(new THREE.Vertex(new THREE.Vector3(-100, 0, 0)));
    	geometry.vertices.push(new THREE.Vertex(new THREE.Vector3(100, 0, 0)));

		targetLine = new THREE.Line( geometry, new THREE.LineBasicMaterial( { color: 0xFF0000 } ) );
		scene.add(targetLine);
		
		// SPHERE LINE *********
		sphereLine = new THREE.Line( geometry, new THREE.LineBasicMaterial( { color: 0x00FF00 } ) );
		scene.add(sphereLine);
		
		

		// and the camera
		scene.add(camera);

		// create a point light
		var pointLight = new THREE.PointLight( 0xFFFFFF );

		// set its position
		pointLight.position.x = 10;
		pointLight.position.y = 50;
		pointLight.position.z = 130;

		// add to the scene
		scene.add(pointLight);
		

		window.addEventListener( 'resize', onWindowResize, false );

	}
	
	
  function rotateVector2(V, ang) {
  	 var l = V.length();
  	 var VT = new THREE.Vector2(V.x,V.y);
  	 
  	 var sang = Math.atan2(V.y, V.x);
  	 
  	 sang += ang;
  	 VT.x = l * Math.cos(sang);
  	 VT.y = l * Math.sin(sang);	 
  	  
  	 return VT;
  }
  
  
  function animate() {

		requestAnimationFrame( animate );
		//setTimeout( function() { requestAnimationFrame( animate ); }, 1000 / 10 );
		
		if (jugControl.pause) return;
		
		frame +=1;
		var thisTime = new Date();
		simTime += thisTime - lastTime;
		lastTime = thisTime;
		
		
		var magAng = magnet.rotation.z;
		
		
		// sphere position vector
		var SP = new THREE.Vector2(sphere.position.x, sphere.position.y);
		
		// sphere position in magnet coordinates
		var SPM = new THREE.Vector2(SP.x, -(magnet.position.y - SP.y));
		SPM = rotateVector2(SPM,magAng);
		
		// gravity vector, and in magnet coordinates
		var G = new THREE.Vector2(0,-jugControl.gravity);
		var GM = rotateVector2(G, magAng);
		
		
		// sphere velocity vector in magnet coordinates
		var VM = new THREE.Vector2(sphere.v.x, sphere.v.y);
		VM = rotateVector2(VM,magAng);
		
		
		// centripetal force vector in magnet coordinates
		var CM = new THREE.Vector2(SPM.x,SPM.y);
		var cR = CM.length();  // centripetal radius
		CM.normalize();
		var cMag = 1.0 * sqr(VM.length()) / cR;
		CM.multiplyScalar(cMag);
		
		
		
		
		// update line positions
		var VT = new THREE.Vector2(0,-jugControl.targetDist);
		VT = rotateVector2(VT,magAng);
		targetLine.position.x = magnet.position.x + VT.x;
		targetLine.position.y = magnet.position.y +VT.y;
		targetLine.rotation.z = magAng;
		
		sphereLine.position.x = sphere.position.x;
		sphereLine.position.y = sphere.position.y;
		sphereLine.rotation.z = magAng;


		// update sphere position
		
		var dist = SPM.length();
		
		
		PID.error = -SPM.y - jugControl.targetDist + (Math.random()-0.5)* jugControl.sensorNoise;
		
		
		
		// what if we use velocity required to reach target height!
		// calc max height for current conditions
		var mh = sqr(sphere.v.y) / (2 * jugControl.gravity);
		
		
		
		//PID.smootherror = (PID.smootherror * 1 + PID.error)/2;
		PID.smootherror = PID.error;
		
		
		PID.ierror += PID.smootherror;
		PID.ierror *= jugControl.IDecay;
		
		
		// clamp ierror
		if (PID.ierror > 100) PID.ierror = 100;
		if (PID.ierror < -100) PID.ierror = -100;
		
		PID.derror = PID.smootherror - PID.lerror;
		
		PID.lerror = PID.smootherror;
		
		
		
		
		var f = jugControl.P * PID.smootherror + PID.ierror * jugControl.I + PID.derror * jugControl.D;
		
		if (f < 0) f = 0;
		
		
		if (PID.error < 0) {
			if (sphere.v.y  < 0) {
				$("#info").html("cancelling");
				
				// ??  some kind of cancelling force?
				//f = -sphere.v.y/2;
				f = 0;
				
				
			} else {
				f = 0;
				
				$("#info").html("dropping");
			}
			
		} else {
			
			// calc required velocity from current position
			
			//var vreq = Math.sqrt(2*jugControl.gravity * PID.error);
			var vreq = Math.sqrt(2*(-GM.y + CM.y) * PID.error);
			
			// work out delta
			var vc = vreq - sphere.v.y;
			
			f = vc ;
			
			
			$("#info").html("pulling");
			
		}
		
		
		if (f > 0) {
			// add in integral control
			//f += PID.ierror * jugControl.I;
		
			// now calc required f to achieve desired magnetic field strength
			
			var V = calcSolenoidField(SPM.x,SPM.y,20,50,f,10);
			var lc =0;
			var ftarget = f;
			
			// assume straight line and solve
			f = (ftarget / V.x) * f;	
			
		}
		
		
		
		
		//var V = calcSolenoidField(x,y,20,50,f,5);
		var VO = calcSolenoidField(SPM.x,SPM.y,20,50,f,10);
		
		VO.y = VO.y * (SPM.x < 0?-1:1);
		
		// rotate V back into world coordinates
		// invert axes
		var VT = new THREE.Vector2(VO.y,VO.x);
		
		
		V = rotateVector2(VT,-magAng);
		
		
		var fy = V.y;
		var fx = V.x;
		
		
		sphere.v.x *= 0.98;  
		sphere.v.x += (fx);
		
		sphere.v.y *= 0.98;
		sphere.v.y += (fy - jugControl.gravity);  
		
		
		sphere.position.x += sphere.v.x;
		sphere.position.y += sphere.v.y;
		
		
		// control loop for magnet angle
		// angle is relative to magnet axis
		
		var penT = 2 * Math.PI * Math.sqrt(SPM.length() / jugControl.gravity);
		
		var sAng = Math.atan2(SPM.x,-SPM.y);
		var driveAng = jugControl.targetAng * Math.PI/180 + 0.1;
		var drive = 0.04;
		
		if (jugControl.coast) {
			if ((jugControl.phase && SPM.x <=0) || (!jugControl.phase && SPM.x >=0)) {
				jugControl.coast = false;
			
				jugControl.oscillations += 1;
			}	
			
		} else {
			if (jugControl.phase) {
				// driving clockwise
				// switching target is when sphere velocity is zero
			
				if (sAng > driveAng) {
					jugControl.phase = false;
					jugControl.coast = true;
				
					// increase velocity
					//jugControl.driveV += 0.001;
					
					jugControl.targetAng += 1;
				}
			
			} else {
				// driving counterclockwise
				// -5
				driveAng *= -1;
			
				drive *= -1;
		
				if (sAng < driveAng) {
					jugControl.phase = true;
					jugControl.coast = true;
					//jugControl.driveV += 0.001;
				}
			}
			
			if (jugControl.driveV > 3) jugControl.driveV = 3;
			
		
			magnet.rotation.z += (driveAng - sAng)/2;
		}
		
		
		
		
		var canvas=document.getElementById('canvas');
		var ctx=canvas.getContext('2d');

		ctx.clearRect(0, 0, canvas.width, canvas.height)
		ctx.strokeStyle = "#CCC";
		
		var cx = 100;
		var cy = 100;
		
		// draw x
		ctx.beginPath();
		ctx.moveTo(-100 + cx, cy);
		ctx.lineTo(100 + cx, cy);
		ctx.stroke();
		
		
		// draw y
		ctx.beginPath();
		ctx.moveTo(cx, cy-100);
		ctx.lineTo(cx, cy+110);
		ctx.stroke();
		
		ctx.strokeStyle = "#000";
		
		// draw magnet
		ctx.strokeRect(cx - 10, cy - 25, 20, 50);
		
		// draw sphere
		ctx.beginPath();
		ctx.arc(-SPM.x + cx, -SPM.y + cy, 10, 0, 2*Math.PI);
		ctx.stroke();
		
		// draw gravity field vector
		ctx.beginPath();
		ctx.strokeStyle = "#F00";
		ctx.moveTo(cx - SPM.x, cy -SPM.y);
		ctx.lineTo(cx - SPM.x - 20*GM.x, cy - SPM.y - 20*GM.y);
		ctx.stroke();
		
		// draw velocity vector
		ctx.beginPath();
		ctx.strokeStyle = "#550";
		ctx.moveTo(cx - SPM.x, cy -SPM.y);
		ctx.lineTo(cx - SPM.x - 20*VM.x, cy - SPM.y - 20*VM.y);
		ctx.stroke();
		
		
		// draw centripetal force vector
		ctx.beginPath();
		ctx.strokeStyle = "#00F";
		ctx.moveTo(cx - SPM.x, cy -SPM.y);
		ctx.lineTo(cx - SPM.x - 20*CM.x, cy - SPM.y - 20*CM.y);
		ctx.stroke();
		
		
		// draw magnetic field vector
		ctx.beginPath();
		ctx.strokeStyle = "#0F0";
		ctx.moveTo(cx - SPM.x, cy -SPM.y);
		ctx.lineTo(cx - SPM.x - 20*VT.x, cy - SPM.y - 20*VT.y);
		ctx.stroke();
		
		
		if (sphere.position.y > magnet.position.y - 45) {
			sphere.position.y = magnet.position.y - 45;
			sphere.v.y = 0;
		}
		if (sphere.position.y < -100) {
			sphere.position.y = -100;
			sphere.v.y = 0;
		}
		
		if (frame < totalPoints) {
			data[frame] = [frame,sAng];
			updatePlot();
		} else {
			frame = 0;
		}
		
		renderer.render( scene, camera );

	}
  
  
  function onWindowResize() {

		camera.aspect = window.innerWidth / window.innerHeight;
		camera.updateProjectionMatrix();

		renderer.setSize( window.innerWidth, window.innerHeight );

	}
  
  jQuery(document).ready(function($) {
	
	plot = $.plot("#placeholder", [ getData() ], {
			series: {
				shadowSize: 0	// Drawing is faster without shadows
			}
		});
	
	init();
	animate();

  });
  
  (function() {
    window.onmousedown = handleMouseDown;
    function handleMouseDown(event) {
        event = event || window.event; // IE-ism
        mx = event.clientX;
        my = event.clientY;
        md = true;
        // event.clientX and event.clientY contain the mouse position
    }
})();

  
});
</script>


</head>
<body>

	<div id="info"></div>

	<div id="placeholder" class="graph"></div>

	<canvas id="canvas" width="400" height="400" style="position:absolute;"></canvas>
	
</body>
</html>
